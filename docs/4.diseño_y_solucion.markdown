---
layout: page
title: Diseño y solución
nav_order: 4
permalink: /diseño y solución/
---

## Diseño físico

El sistema operará inicialmente en un modo de funcionamiento normal. La veleta se encuentra en la parte superior, mientras que el anemómetro se encuentra en la parte inferior.

El interior del cilindro alberga el sistema mecánico y electrónico, que incluye una varilla central que atraviesa verticalmente el dispositivo y se conecta a un mecanismo de guía en espiral accionado por un servomotor. Además, se han instalado dos varillas guía adicionales que atraviesan la plataforma inferior. Estas varillas estabilizan el movimiento de la plataforma al subir y bajar en el modo de resguardo o en el modo de reposo (sleep mode), minimizando posibles desviaciones en su trayectoria y asegurando un desplazamiento correcto.

La plataforma que sostiene el anemómetro se ubica en la parte inferior del cilindro y está equipada con un anemómetro de tres paletas con semiesferas. Dada la posición en la que se encuentra, al ser resguardado, queda fuera del alcance de factores externos que puedan dañarlo, como la lluvia.

Si el anemómetro se hubiera colocado en la parte superior junto con la veleta, el sistema de protección requeriría una tapa adicional que se activaría cuando el anemómetro estuviera completamente dentro de la carcasa. Esta tapa debería incluir un borde de goma para asegurar un sellado efectivo dentro del tubo de la carcasa y así evitar el ingreso de agua de lluvia.

La incorporación del panel solar nos llevó a analizar cuidadosamente su ubicación para optimizar la captación de luz solar y, en consecuencia, maximizar la generación de energía. Para lograrlo, consideramos el recorrido diario del sol, orientando el panel estratégicamente de manera que reciba la mayor cantidad de radiación solar posible. La orientación también nos permitirá calibrar a la veleta para que pueda reportar la dirección del viento correctamente. 

En caso de utilizar varios dispositivos, la ubicación de cada panel deberá adaptarse tanto a la trayectoria del sol en su posición específica como a la alineación de la veleta, que tomamos como referencia. 

A continuación, presentamos imágenes del resultado final del dispositivo. En la primera imagen, se puede apreciar el diseño exterior, que representa el aspecto visual definitivo del dispositivo y cómo se presenta al usuario.

En la segunda imagen, se muestra el interior del dispositivo, donde se pueden observar claramente los diferentes componentes que forman parte del sistema. Además, se destacan las varillas que conforman el mecanismo encargado del resguardo del dispositivo, un elemento clave en su funcionamiento.  

Estas imágenes ilustran cómo logramos integrar los aspectos físicos y electrónicos del proyecto, combinando diseño y funcionalidad para crear un sistema completo.

![Imagen diseño Breeze](/img/foto-breeze-1.png)

![Imagen diseño Breeze interior](/img/foto-breeze-3.png)

## Diagrama de módulos inicial

El sistema de la estación meteorológica está compuesto por varios módulos clave que interactúan para recopilar, procesar y transmitir los datos meteorológicos. Es esencial comprender el funcionamiento de cada uno de estos bloques para apreciar cómo el dispositivo proporciona una solución integral. A continuación se presenta un diagrama de módulos que ilustra su estructura:

![Diagrama de módulos](/img/Diagrama_modulos.png)

En el apartado de solución, se describe detalladamente cómo funcionan los distintos módulos del sistema, especificando sus funciones individuales y el enfoque utilizado para integrarlos de manera que trabajen de forma conjunta. Cada módulo fue diseñado para cumplir con un objetivo específico, ya sea sensar, recibir y enviar datos, o activar diversas funcionalidades del sistema. Esta integración asegura que los módulos colaboren de manera eficiente para cumplir con los requerimientos planteados.  

El diagrama de módulos representó nuestro primer acercamiento hacia una división estructurada de las tareas necesarias para implementar las distintas funcionalidades del sistema. Este esquema no solo nos permitió organizarnos de manera más efectiva, sino también centrarnos en cada módulo con claridad, facilitando la identificación de lo que debíamos hacer o, al menos, de las áreas específicas que requerían investigación para lograr nuestros objetivos.  

A partir de este diagrama, se asignaron responsabilidades entre los integrantes del equipo, con cada miembro trabajando en un módulo específico. Esta estrategia de división del trabajo permitió avanzar de forma simultánea en diferentes partes del proyecto, optimizando el tiempo y los recursos disponibles. Una vez que cada módulo estuvo desarrollado, los integramos en la placa principal, asegurándonos de que todos funcionaran de manera sincronizada como un sistema cohesivo. Este enfoque colaborativo fue clave para el progreso y éxito del proyecto. 


# Solución

## Velocidad del viento

### Anemometro usando motor
Inicialmente se había considerado sensar la velocidad del viento utilizando un motor con aspas. La idea consistía de utilizar la rotación de las aspas, impulsada por el viento para generar una diferencia de potencial en los bornes del motor, la cual se conectaba a un pin analógico de la ESP32 para medir el voltaje, asumiendo que este era proporcional a la velocidad del viento. Sin embargo, surgieron dos problemas: el voltaje inducido era inferior a 1 voltio, lo que dificultaba una lectura precisa, y además, dicho voltaje presentaba fluctuaciones significativas, resultando en mediciones poco fiables.

### Anemometro usando sensor IR
Para solventar los problemas que surgian de usar un motor para medir la velocidad del viento, se decidió utilizar un sensor de presencia infra rojo. Este sensor se conecta a un pin digital de la ESP32 y se activa cada vez que una aspa del anemómetro pasa sobre él. Midiendo la frecuencia de activación del sensor, se puede estimar la velocidad de rotación de las aspas y, consecuentemente, la velocidad del viento de manera más precisa y fiable.

### Desarrollo del anemometro
Utilizamos un módulo de detección óptica de la marca SunFounder. Diseñamos e imprimimos en 3D un rotor de tres palas igualmente espaciadas con forma semiesférica, optimizadas aerodinámicamente para captar la fuerza del viento. Las palas están montadas en un sistema rotatorio con un rodamiento de baja fricción en la base, lo que permite un giro libre y suave.

#### Sensor de presencia infrarrojo
![imagen_sensor_distancia](/img/sensor_distancia.jpeg)

#### Diseño 3D paletas anemometro
![imagen_paletas](/img/paletas.png)

Cada vez que el sensor óptico detecta una pala, registra el tiempo transcurrido hasta la detección de la siguiente. Este intervalo temporal permite calcular la frecuencia de rotación, a partir de la cual estimamos la velocidad angular del conjunto. Finalmente, esta velocidad angular se convierte en una estimación precisa de la velocidad del viento mediante una constante de calibración específica para el diseño del anemómetro. Este proceso de conversión ofrece una aproximación fiable de la velocidad del viento basada en las características del sistema. 

```
// Lee la velocidad del viento
void check_anemometro(){
  if (digitalRead(pin_anem) == 0 && !contando_vuelta) {
    tiempo_vuelta_inicio = millis();
    contando_vuelta = true;
  } else if (digitalRead(pin_anem) == 0 && contando_vuelta && se_destapo) {
    tiempo_vuelta = millis() - tiempo_vuelta_inicio;
    contando_vuelta = false;
    se_destapo = false;
    /* De donde sale el valor 300 ?
    25cm circunferencia -> 1/3 son 8.333cm = 0.0833m = 0.00008333km
    tiempo de vuelta esta en milisegundos -> 1/1000 segundos = 1/60000 minutos = 1/ 3600000 horas 
    0.00008333/(1/3.600.000) = 300 mas o menos
    */
    viento =  300 / tiempo_vuelta;
  }
  if (contando_vuelta && (digitalRead(pin_anem) == 1)) {
    se_destapo = true;
  }

  // Para cubrir el caso que se queda quieto entonces no actualiza el valor de viento.
  if(millis() - tiempo_vuelta_inicio > 2000){
    contando_vuelta = false;
    viento = 0;
  }
}
```
Para traducir de frecuencia de giro a velocidad del viento se realizo los siguientes calculos:
```
Circunferencia = 25cm
```
Hay 3 aspas por lo que
```
Distancia entre aspas = 25cm / 3 = 8,33333cm
```
Traduciendo de Cm a Km
```
Distancia entre aspas en km = 8,33333 / 100 000 = 0,00008333333km
```
El tiempo se toma en milisegundos por lo que
```
tiempo de 1/3 vuelta en horas =  tiempo de 1/3 vuelta en milisegundos / 3 600 000 
```
Entonces
```
Velocidad en km/h = Distancia entre aspas en km / tiempo de vuelta en horas = 0,00008333333 *  3600000 /  tiempo de 1/3 vuelta en milisegundos

Velocidad en km/h = 300 / tiempo de 1/3 vuelta en milisegundos
```

### Conclusiones y mejoras
Aunque la solución final con el sensor de presencia lumínico mejoró la medición de la velocidad del viento, no está exenta de errores. En condiciones de viento muy bajo, una aspa puede quedar sobre el sensor. Si el sensor no detecta esto correctamente, puede generar activaciones y desactivaciones rápidas, simulando una alta velocidad de giro de las aspas. Esto podría interpretarse erróneamente como un viento fuerte, cuando en realidad es un falso positivo debido a la detección incorrecta del sensor. Sin embargo, esta situación se considera aceptable porque el objetivo de la estación meteorológica no es medir con precisión en condiciones de viento bajo, sino registrar velocidades de viento significativas. Además, el usuario dispone de los datos teóricos de predicción, lo que facilita la detección de errores en el sensor cuando existe una discrepancia significativa entre las mediciones del sensor de viento y los valores teóricos.

## Dirección del viento

Para medir la dirección del viento, empleamos un encoder rotativo KY-040 al que acoplamos una veleta fabricada en 3D. La veleta aplica una fuerza rotacional sobre el eje del encoder, haciendo que éste gire hasta encontrar la posición de menor resistencia y alinearse con la dirección del viento.

#### Diseño 3D veleta
![imagen_veleta](/img/veleta.png)

#### Encoder KY-040
![imagen_encoder](/img/encoder.jpeg)

La placa ESP32 monitorea en tiempo real la rotación del encoder, registrando el desplazamiento angular de la veleta. La posición inicial del encoder se calibra previamente para alinearlo con el norte geográfico, de manera que cualquier cambio en la posición de la veleta pueda interpretarse en términos de direcciones cardinales. Este sistema permite un seguimiento preciso de la dirección del viento mediante el procesamiento de los pulsos generados por el encoder, estableciendo una correlación directa entre la posición angular del eje y la dirección en grados con respecto al norte.

```
void check_encoder(){
  estado_actual_clk = digitalRead(pin_clk);
  //Si cambio CLK entonces giro para algun lado tengo que ver para que lado giro dependiendo de DT
  
  if((estado_actual_clk != estado_anterior_clk) ){
    if(digitalRead(pin_dt) != estado_actual_clk){
      // Se movio antihorario
      contador --;      
    }else{
      // Se movio horario
      contador ++;
    }
  }
  if(contador >= 40 || contador <= -40){
    contador = 0;
  }
  estado_anterior_clk = estado_actual_clk;
  actualizar_direccion();
}
// Funcion auxiliar de check_encoder
void actualizar_direccion(){
  int valor = contador * 9;
  if(valor < 0){
    valor = valor + 360;
  }
  direccion = valor;
}
```

## Sleep Mode

Con el objetivo de optimizar el consumo de energía, diseñamos una rutina dentro del programa que permite al dispositivo entrar en modo de suspensión ligera (light sleep-mode). Este modo reduce significativamente el consumo energético, lo que se traduce en una mejora notable en la autonomía del dispositivo, prolongando el tiempo de operación antes de requerir una recarga de baterías.

La implementación de esta rutina se basa en la configuración de pines de wake-up, los cuales están programados para "despertar" al dispositivo al recibir una señal. En nuestro caso, definimos los pines asociados a la veleta como pines de wake-up. Esto se debe a que los movimientos de la veleta deben ser registrados continuamente para mantener una referencia precisa de la dirección del viento. Además, se configura un wakeup timer que activa el dispositivo cada hora. Sin embargo, este intervalo puede ajustarse para que el dispositivo se despierte con menos frecuencia, en caso de ser necesario optimizar aún más el consumo de energía.

```
void ahorro_energia(){
  // Configura el modo Light Sleep
  if(digitalRead(pin_clk) == 0){
    esp_sleep_enable_ext0_wakeup(GPIO_NUM_15, 1);
  }else{
    esp_sleep_enable_ext0_wakeup(GPIO_NUM_15, 0);
  }  
  esp_sleep_enable_timer_wakeup(3600000000); // tiempo de sleep 1 hora
  Serial.println("Entrando en modo Sleep");
  delay(100);
  esp_light_sleep_start(); // Inicia el modo Sleep
  Serial.println("Despertando del modo Sleep");
  tiempo_ultimo_sleep = millis();
  esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_EXT0);
}
```
Cuando el dispositivo entra en sleep-mode, suspende todas las operaciones no esenciales y ejecuta únicamente las subrutinas necesarias para monitorear los pines de wake-up. Si estos detectan una señal, el dispositivo puede reactivarse de inmediato para procesar la información relevante. Al minimizar las tareas en este estado, el consumo energético se reduce drásticamente, maximizando la eficiencia del sistema y prolongando su tiempo operativo.

Este diseño no solo asegura un bajo consumo de energía, sino que también mantiene la funcionalidad clave del dispositivo, como la recolección de datos críticos en tiempo real. La combinación de eficiencia energética y desempeño continuo hace que esta solución sea ideal para dispositivos IoT que operan en entornos donde el acceso a la energía es limitado o intermitente.

## Interaccion Sleep Mode + Encoder
En el desarrollo de la estación meteorológica con ESP32, se buscó implementar el modo de ahorro de energía “Light Sleep Mode” para reducir el consumo energético, especialmente durante la noche. Sin embargo, surgió un problema. Al utilizar un encoder incremental para medir la dirección del viento, el dispositivo perdía la referencia si el encoder cambiaba de posición mientras estaba en modo sleep.

Para abordar este desafío, se configuraron interrupciones externas en los pines del ESP32 conectados al encoder. Esto permitió que, cada vez que el encoder detectaba un cambio de posición, las interrupciones despertaran automáticamente al dispositivo del modo sleep, asegurando que se pudiera registrar el movimiento y mantener la referencia.
```
if(digitalRead(pin_clk) == 0){
    esp_sleep_enable_ext0_wakeup(GPIO_NUM_15, 1);
  }else{
    esp_sleep_enable_ext0_wakeup(GPIO_NUM_15, 0);
}  
```
A pesar de esta mejora, aún se presentaban ocasionales fallos en la precisión del encoder incremental. Esto llevó a una conclusión final:
	1.	Si se requiere mantener el modo “Light Sleep Mode” activado para optimizar el consumo energético, la solución ideal sería sustituir el encoder incremental por un encoder absoluto, el cual permite conservar siempre la referencia de la dirección del viento sin importar el estado del dispositivo.
	2.	Si el ahorro energético no es prioritario, es posible prescindir del modo Light Sleep Mode y continuar utilizando el encoder incremental, ya que este funciona correctamente cuando el dispositivo permanece activo.

## Temperatura, humedad y presion

Para medir temperatura, humedad y presión atmosférica, utilizamos el módulo de sensores ambientales BME/BMP280. Este módulo emplea el protocolo de comunicación I2C, lo que permite transferir datos de múltiples sensores a través de dos líneas: SCL (Serial Clock Line) y SDA (Serial Data Line). Esta configuración es especialmente eficiente, ya que permite adquirir y transmitir diversos parámetros ambientales usando solo dos pines de la placa de desarrollo ESP32, optimizando el uso de los recursos de entrada y salida del microcontrolador. 

#### Sensor BMP280
![imagen_sensor](/img/sensor.jpeg)

Utilizando la libreria ```<Adafruit_BME280.h>``` es muy sencillo obtener la informacion del sensor como se puede ver en la funcion a continuacion:
Se inicializa una instancia del sensor
```
Adafruit_BME280 sensor;
if (sensor.begin(0x76)) {
    Serial.println("Se inicio el sensor");
}
```
La siguiente funcion obtiene los datos del sensor.
```
void check_sensor(){
  temperatura = sensor.readTemperature();
  humedad = sensor.readHumidity();
  presion = sensor.readPressure() / 100;
}
```

## Modo de resguardo

El mecanismo de resguardo utiliza un servomotor de rotación continua MG996R, que acciona una varilla roscada para desplazar la plataforma que sostiene el sistema del anemómetro. Al girar en una dirección, la varilla roscada mueve la plataforma hacia el interior de la carcasa plástica, protegiendo todos los componentes del sistema. Este diseño permite el resguardo automático de los sensores y del anemómetro, minimizando su exposición a condiciones ambientales adversas cuando no están en uso.

#### Servomotor MG996R
![imagen_servo](/img/servo.jpeg)

Este mecanismo se activa cuando se cumplen ciertas condiciones definidas en las reglas configuradas dentro de ThingsBoard. Estas condiciones, consideradas en conjunto, representan un panorama de clima adverso en las coordenadas donde se encuentra ubicado el dispositivo.  

Las condiciones están basadas en los datos obtenidos de la API, que incluyen información sobre precipitaciones y velocidad del viento. Además, se integran las mediciones directas de velocidad del viento realizadas por nuestro dispositivo para complementar la evaluación. El mecanismo se activa si las precipitaciones superan un valor umbral definido y si la velocidad del viento, ya sea estimada (proveniente de la API) o medida directamente, supera un límite establecido.  

Una vez activado el mecanismo, el servomotor comienza a girar en una dirección específica según la acción requerida: resguardar el dispositivo o sacarlo del resguardo. Cuando el dispositivo se resguarda, el servomotor sigue girando hasta que alcanza un botón de tope o fin de carrera, instalado como límite físico del movimiento. Este botón detiene automáticamente el servomotor, indicando que el resguardo se ha completado. El comportamiento esta contenido en la logica a continuacion:

```
void check_resguardo(){
  // Va negado porque como es PULLUP siempre da 1 a menos de que este presionado.
  tope_inferior = !digitalRead(pin_tope_inferior);
  tope_superior = !digitalRead(pin_tope_superior);
  if (resguardo && !tope_inferior){
    servo.write(110);    
  }else if(!resguardo && !tope_superior){
    servo.write(70);    
  }else{
    servo.write(90);
  }
}
```

## Alimentacion

### Alimentacion sin panel solar

En las etapas iniciales del proyecto, se decidió utilizar baterías recargables del tipo 18650. Para el diseño preliminar, se conectaron dos baterías 18650 en serie, cada una con un voltaje nominal de 3.7V. Esta configuración en serie permitió obtener un voltaje total de aproximadamente 7.4V (con variaciones dependiendo del estado de carga, entre 7V y 8V). Luego, utilizando un modulo step-down se alcanzaban los 5v deseados para el funcionamiento del dispositivo.

### Incorporacion del panel solar

El proyecto enfrentó un desafío al intentar integrar un panel solar para cargar las baterías 18650. En primer lugar, los reguladores de carga disponibles en el mercado están diseñados principalmente para manejar una sola batería 18650, lo que imposibilitaba cargar dos baterías conectadas en serie.
Para resolver este problema, se optó por simplificar el sistema reduciendo la configuración a una sola batería 18650. Se utilizó un controlador de carga compatible con dicha batería, conectado al panel solar para gestionar la recarga de manera eficiente.
Posteriormente, se incorporó un módulo step-up (convertidor elevador) para aumentar el voltaje de salida de la batería, pasando de 3.7V a 5V. Aunque la reducción a una sola celda disminuye la capacidad energética total del sistema, la implementación de un panel solar adecuadamente dimensionado proporciona la posibilidad de operación continua sin necesidad de recarga manual.

#### Controlador de carga
![imagen_cargador](/img/cargador.jpeg)

#### Panel solar
![imagen_panel](/img/panel.jpeg)

#### Convertidor Step-Up
![imagen_stepup](/img/stepup.jpeg)

## Diagrama de flujo del loop

A continuación se presenta un diagrama de flujo correspondiente al código generado para controlar al sistema.

![imagen_flujo_loop](/img/flujo_loop.png)

- Recuperación de conexión: Se verifica y establece la conexión necesaria para el funcionamiento, asegurando que el sistema esté preparado para enviar datos. En caso de que la conexion se haya caido se llama a las funciones que recuperan tanto la conexion con el router como la conexion con el servidor de thingsboard.

- Lectura del encoder (check_encoder()): Se evalúan los cambios en las señales de los pines del encoder (estado_actual_clk y estado_actual_dt), lo que permite calcular la dirección y actualizar el contador asociado.

- Lectura del anemómetro (check_anemometro()): Se analiza el estado del sensor de distancia para calcular el tiempo de rotación, obteniendo así la velocidad del viento.

- Lectura del sensor BME280 (check_sensor()): Se capturan los valores de temperatura, humedad y presión atmosférica, que se almacenan y actualizan en el sistema.

- Envío de telemetría (enviar_telemetria()): Los datos recolectados se empaquetan en formato JSON (incluyendo dirección del viento, velocidad, temperatura, humedad y presión) y se publican en el canal de telemetría. Esto permite recibir los datos en la plataforma IoT para poder procesarlos y presentarlos en los dashboards correspondientes.

- Modo de ahorro de energía (ahorro_energia()): Dadas las condiciones correctas, se activa un modo de bajo consumo mediante interrupciones externas y temporizadores, manteniendo al sistema en un estado de espera eficiente hasta que ocurra un cambio en los pines del encoder. 

## Diagrama de módulos final

A partir del diagrama de módulos inicial, logramos orientar de manera efectiva el desarrollo de las diferentes partes del proyecto, facilitando su implementación y asegurando una integración exitosa de todos los componentes. Este enfoque modular nos permitió abordar cada sección del proyecto de manera organizada y eficiente, asegurando que cada módulo cumpliera con su función antes de integrarlo con los demás.

Finalmente, el resultado de este proceso fue el siguiente diagrama de flujo, que representa la versión final del sistema completamente integrado.

![imagen_de_interacciones](/img/interacciones.png)

A continuación, se detallan los componentes principales y su integración:

#### Microcontrolador ESP32

El ESP32 actúa como el núcleo del sistema, gestionando las señales provenientes de los sensores y controlando los actuadores. Sus principales conexiones son las siguientes:

- Servo motor: Controlado mediante señales PWM generadas desde el pin GPIO 12.
  
- Botones: Dos botones físicos, uno superior y otro inferior, están conectados a los pines GPIO 19 y GPIO 18, respectivamente, configurados como entradas digitales para detectar presiones.
  
- Encoder: Este dispositivo está conectado a los pines GPIO 14 y GPIO 15, los cuales reciben señales digitales para medir posición o velocidad angular.
  
- Sensor de distancia: Conectado al pin GPIO 5, configurado como entrada digital, este sensor permite la detección de proximidad o distancia.
  
- Sensor BME280: Utiliza la interfaz de comunicación I2C a través de los pines GPIO 22 (SCL) y GPIO 21 (SDA) para registrar temperatura, humedad y presión ambiental.

#### Sistema de Alimentación

El sistema está diseñado para ser autónomo empleando una batería recargable y energía solar:

- Panel solar: Proporciona energía renovable al sistema. La corriente generada por el panel es regulada antes de alimentar la batería.
  
- Controlador de carga para batería 18650: Este módulo regula la carga de la batería de litio 18650, protegiéndola contra sobrecargas y optimizando su rendimiento.
  
- Convertidor Step-Up (3.7V a 5V): Eleva la tensión de la batería (3.7V) a 5V, lo que permite alimentar al ESP32 y otros componentes electrónicos que operan a este voltaje.
